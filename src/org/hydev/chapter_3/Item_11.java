package org.hydev.chapter_3;

// 第 11 条：覆盖 equals 时总要覆盖 hashCode.
public class Item_11 {
    // 在每个覆盖了 equals 方法的类中，都必须覆盖 hashCode 方法.
    // 如果不这样做的话，就会违反 hashCode 的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，
    // 这类集合包括 HashMap 和 HashSet. 下面是约定的内容，摘自 Object 规范.

    // 1. 在应用程序的执行期间，只要对象的 equals 方法的比较操作所用到的信息没有被修改，
    // 那么对同一个对象的多次调用，hashCode 方法都必须始终返回同一个值.
    // 在一个应用程序与另一个应用程序的执行过程中，执行 hashCode 方法返回的值可以不一致.

    // 2. 如果两个对象根据 equals(Object) 方法比较是相等的，那么调用这两个对象中的 hashCode 方法都必须产生同样的整数结果.
    // 3. 如果两个对象根据 equals(Object) 方法比较是不相等的，那么调用这两个对象中的 hashCode 方法，
    // 则不一定要求 hashCode 方法必须产生不同的结果. 但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能.

    // [V] 总的来说，equals 相等时 hashCode 必须相等；equals 不等时 hashCode 最好不相等.

    // 因没有覆盖 hashCode 而违反的关键约定是第 2 条：相等的对象必须具有相同的散列码.
    // [V] 如果仅仅覆盖了 equals，而没有覆盖 hashCode，将会导致如下的错误行为：
    // Map<PhoneNumber, String> m = new HashMap<>();
    // m.put(new PhoneNumber(707, 867, 5309), "Jenny");
    // 此时，你可能期望 m.get(new PhoneNumber(707, 867, 5309)) 会返回 "Jenny"，但它实际上返回的是 null.
    // 由于 PhoneNumber 类没有覆盖 hashCode 方法，从而导致两个相等的实例具有不相等的散列码，违反了 hashCode 的约定.
    // 因此，put 方法把电话号码对象存放在一个散列桶中，get 方法却在另一个散列桶中查找这个电话号码.
    // 即使这两个实例正好被放到同一个散列桶中，get 方法也必定会返回 null，
    // 因为 HashMap 有一项优化，可以将与每个项关联的散列码缓存起来，如果散列码不匹配，也就不再去检验对象的等同性.

    // [V] 考虑下面的 hashCode 方法，它是合法的，但是它永远都不应该被正式使用：
    // @Override public int hashCode() { return 42; }
    // 这使得每个对象都具有同样的散列码. 因此，每个对象都被映射到同一个散列桶中，使散列表退化为链表.
    // 它使得本应该线性时间运行的程序变成了以平方级时间在运行. 对于规模很大的散列表而言，这回关系到散列表能否正常工作.

    // 理想状况下，散列函数应该把集合中不相等的实例均匀地分布到所有可能的 int 值上. 要想完全达到这种理想情形是非常困难的.
    // 幸运的是，相对接近这种理想理想情形则并不太困难. 下面给出一种简单的解决办法：
    // 1. 声明一个 int 变量并命名为 result，将它初始化为对象中第一个关键域的散列码 c，如步骤 2.a 中计算所示（如第 10 条所述，关键域是指影响 equals 比较的域）.
    // 2. 对象中剩下的每一个关键域 f 都完成以下步骤：
    //    a. 为该域计算 int 类型的散列码 c：
    //         I. 如果该域是基本类型基本类型，则计算 Type.hashCode(f)，这里的 Type 是装箱基本类型的类，与 f 的类型相对应.
    //        II. 如果该域是一个对象引用，并且该类的 equals 方法通过递归地调用 equals 的方式来比较这个域，则同样地为这个域递归地调用 hashCode.
    //            如果需要更复杂的比较，则为这个域计算一个 "范式"，然后针对这个范式调用 hashCode.
    //            如果这个域的值为 null，则返回 0（或者其他某个常数，但通常是 0）.
    //       III. 如果该域是一个数组，则要把每一个元素当做单独的域来处理. 也就是说，递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤 2.b
    //            中的做法把这些散列值组合起来. 如果数组域中没有重要的元素，可以使用一个常量，但最好不要用 0. 如果数组域中的所有元素都很重要，可以使用 Arrays.hashCode 方法.
    //    b. 按照下面的公式，把步骤 2.a 中计算得到的散列码 c 合并到 result 中：
    //       result = 31 * result + c;
    // 3. 返回 result.

    // 在散列码的计算过程中，可以把衍生域排除在外. 换句话说，如果一个域的值可以根据参与计算的其他域值计算出来，则可以把这样的域排除在外.
    // 必须排除 equals 比较计算中没有用到的任何域，否则很有可能违反 hashCode 约定的第二条.

    // 步骤 2.b 中的乘法部分使得散列值依赖于域的顺序，如果一个类包含多个相似的域，这样的乘法运算就会产生一个更好的散列函数.
    // 例如，如果 String 散列函数省略了这个乘法部分，那么只是字幕顺序不同的所有字符串将都会有相同的散列码.
    // 之所以选择 31，是因为它是一个奇素数. 如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与 2 相乘的等价于移位运算.
    // 使用素数的好处并不很明显，但是习惯上都使用素数来计算散列结果. 31 有个很好的特性，即用移位和减法来代替乘法，可以得到更好的性能：
    // 31 * i == (i << 5) - i. 现代的虚拟机可以自动完成这种优化.

    // 这样的实现方法能够获得相当好的散列函数，但它们并不是最先进的. 它们的质量堪比 Java 平台类库的值类型中提供的散列函数，这些方法对于绝大多数应用程序而言已经足够了.
    // 如果执意让散列函数尽可能地不会造成冲突，请参阅 Guava's com.google.common.hash.Hashing.
    // [V] https://github.com/google/guava/blob/master/guava/src/com/google/common/hash/Hashing.java

    // [V] 也可以使用 Objects 类中的 hash 方法，但它们运行速度更慢一些.
    // 因为它们会引发数组的创建，以便传入数目可变的参数，如果参数是基本类型，还需要装箱和拆箱. 建议只将这类散列函数用于不太注重性能的情况.

    // 如果一个类是不可变的，并且计算散列码的开销也比较大，就应该考虑把散列码缓存在对象内部，而不是每次请求的时候都重新计算散列码.
    // 如果你觉得这种类型的大多数对象会被用作散列键，就应该在创建实例的时候计算散列码.
    // 否则，可以选择 "延迟初始化" 散列码，即一直到 hashCode 被第一次调用的时候才初始化（见第 83 条）.

    // 不要试图从散列码计算中排除掉一个对象的关键域来提高性能.
    // 虽然这样得到的散列函数和运行起来可能更快，但是它的效果不见得会好，可能会导致散列表慢到根本无法使用.
    // 这不只是一个理论问题. 在 Java 2 发行版本之前，一个 String 散列函数最多只能使用 16 和字符，若长度少于 16 个字符就计算所有的字符，
    // 否则就从第一个字符开始，在整个字符串中间隔均匀地选取样本进行计算. 对于像 URL 这种层次状名称的大型集合，该散列函数正好表现出了这里所提到的病态行为.

    // 不要对 hashCode 方法的返回值做出具体的规定，因此客户端无法理所当然地依赖它；这样可以为修改提供灵活性.
    // [V] 仅仅满足 hashCode 规范就可以了；若过多地进行规范，客户端可能会依赖这些规范，从而导致在改进它时无法向后兼容.
}
